数据存放于内存，单线程处理请求的远程字典服务

[toc]

## 基本数据结构

### String
set key value,get key
Simple dynamic String(动态字符串)

### Hash
value本身为一个key-value数据结构
hset key field value, hget key field
hashtable
### List
lpush key value lrange key start end
linklist

### Set
sadd key element ,smebers key
hashtable

### ZSet
zadd key score member

## 高效的数据结构

### SDS

1. 获取字符串长度，时间复杂度为O(1)
2. 会额外分配未使用空间，减少性能损耗
3. 缩短时仅记录free多余空间，后续变更直接使用free中空间，减少内存分配
4. 二进制安全

### 跳跃表
**Redis 跳跃表默认允许最大的层数是 32**
**在跳表中查询任意数据的时平均时间复杂度就是 O(logn)**

就是单条链表加上层级的概念，层级向上后当前节点直接跨界点指向，越往上跨节点越多。命中节点更方便

redis中使用跳表的只有ZSet，有序集合

## 合理的线程模型

让单个线程高效的处理多个连接请求,Redis使用用epoll作为I/O多路复用技术的实现

## Redis的虚拟内存机制
虚拟内存机制就是暂时把不经常访问的数据(冷数据)从内存交换到磁盘中，从而腾出宝贵的内存空间用于其它需要访问的数据(热数据)。通过VM功能可以实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘。这样就可以避免因为内存不足而造成访问速度下降的问题。

  redis的虚拟内存只能解决value太大的问题，因为其全部key都存在内存中，因此如果是key不足，则无法解决问题。

### 缓存穿透

查询一个不存在的数据，缓存未命中，则请求打到数据库上。导致每次查询不存在的数据的请求都会打到数据库

### 原因
1. 业务不合理，大部分数据不存在，但均通过缓存去查询
2. 缓存数据被删除
3. 非法请求

### 解决方案
1. 针对非法请求，做参数校验
2. 缓存设置空值，并设置合理过期时间
3. 布隆过滤器

### 缓存雪崩

大批量缓存同时过期，查询数据量巨大，请求直接打到数据库。

#### 解决方案:
1. 均匀设置过期时间，相对离散
2. redis集群部署，防止宕机导致的缓存雪崩.

### 缓存击穿
这个Key有大量的并发请求过来，从而大量的请求打到db。

1. 互斥锁保持同时只有一个线程访问数据库
2. 不设置过期时间，异步更新数据

### 过期策略

1. **定时过期**
	每一个key设置单独定时器，达到时间立即清除key.堆内存友好，但占用大量cpu资源处理过期数据。

2. **惰性过期**
	当访问具体Key时，才判断是否过期。对内存不友好。

3. **定期过期**
	扫描一定数量的过期key，进行删除.

*redis采用的时惰性+定期过期策略*

## redis内存淘汰策略

不设置、过期时间key(随机，最早过期，lru(最长时间未被使用),lfu(最近使用次数少的)),所有key(lru,lfu,random)


### 使用场景

缓存，分布式锁，共享session

## Redis持久化场景

### RDB策略:

指定时间间隔内，执行指定次数的写操作。自动将内存数据集快照写入磁盘

### AOF策略:
采用日志形式记录写操作，追加至文件。重启后执行AOF文件进行恢复

### 主从模式

master,slave。通过主从复制(全量复制，增量复制)进行数据同步

### 哨兵模式(手动尝试)

通过发送命令，返回被监控redis服务的运行状态。

当监测到master宕机，多个哨兵会同时发起命令。足够多的哨兵确认后，则会自动切换主从

#### Redis分布式锁

1.分布式系统环境，保证一把锁被一台机器的单个线程
2.设置锁时需要设置超时时间，防止持有锁服务宕机，锁未释放。导致死锁
3.避免超时操作后，释放其他线程上的锁。使用requestId做key值。
4.未业务确实足够长(根据数据量计算处理时长)，可另起线程刷新该锁超时时间

### 自旋锁 线程忙等待，循环拿锁

### 互斥锁，线程释放

可重入锁，相同线程拿锁。第一次拿成功，可以再次拿成功


## MySQL与Redis 如何保证双写一致性

## 使用过Redis分布式锁嘛？有哪些注意点呢？

## Redis的Hash 冲突怎么办

相同hash值的key,通过链表格式存放进哈希桶中

## 聊聊Redis 事务机制