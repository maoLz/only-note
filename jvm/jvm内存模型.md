

# 堆
    1. jvm最大内存块，存放对象实例。

# 方法区
    1. 存放类型信息、类静态变量
    2. 常量池 (字符串常量池、包装类常量池)
    3. jdk8后，元空间成为了方法区的一种实现

## 类型信息

    1. 类型全名
    2. 类型父类全名
    3. 类是否为接口
    4. 类型修饰符
    5. 父类接口列表
    6. 字段信息
    7. 方法信息
    8. 静态类变量
    9. 类加载器引用
    10. class类引用
    11. 基本类型常量池


# 虚拟机栈(线程私有)

    1. 仅保存基础数据类型以及自定义对象引用
    2. 栈内数据再超出作用域后，被激动释放

## 栈运行原理
    1. JVM直接对Java栈的操作只有两个,就是对栈帧的压栈和出栈
    2. 在一条活动线程中,一个时间点上,只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧(栈顶栈帧)是有效的,这个栈帧被称为当前栈帧(current Frame) ,与当前栈帧相对应的方法就是当前方法(currentMethod) ,定义这个方法的类就是当前类(current Class)
    3. 执行引擎运行的所有字节码指令只针对当前栈帧进行操作
    4. 如果在该方法中调用了其他方法,对应的新的栈帧会被创建出来,放在栈的顶端,成为新的当前帧.方法返回之际,当前栈帧会传回此方法的执行结果给前一个栈帧,接着,虚拟机会丢弃当前栈帧,使得前一个栈帧重新成为当前栈帧
    5. Java方法有两种返回函数的方式,一种是正常的函数返回,使用return指令;另外一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。不管使用哪种方式,都会导致栈帧被弹出

## 栈帧
    1. 局部变量表
    2. 操作数栈
    3. 动态链接
    4. 方法返回地址
    5. 一些附加信息

# 本地方法栈(线程私有)
native method


# 程序计数器(线程私有)

当线程正在执行一个Java方法，程序计数器记录的是正在执行的JVM字节码指令的地址。如果正在执行的是一个Native（本地方法），那么这个计数器的值则为空（Underfined）。