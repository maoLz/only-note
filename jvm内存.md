
## 栈

往往为线程私有:
	1) 虚拟机栈: 生命周期与线程相同，用于运行class中的方法
	2) 本地方法栈: native方法(调用jdk#c方法)
	3) 程序计数器

## 栈帧:

用于支持虚拟机进行方法调用执行的数据结构。调用开始则栈帧入栈，结束则出栈。

编译时，所需局部变量表，最深操作数栈已确定，并写入方法表Code属性。即栈帧所需分配内存，不受运行影响。

栈帧为线程私有，不能在一个栈帧引入另一线程的栈帧

方法执行 ->创建栈帧1->push进虚拟机栈->执行方法->调用其他方法->创建栈帧2->push->执行结束->frame2pop->frame1成为当前栈帧

## 栈深度:

相同栈空间内(-Xss)能入栈的栈帧的个数。当栈帧内存占用越大（局部变量），栈帧个数越小。深度越小


### 局部变量表
以变量槽为最小单位,未指出所占内存空间大小。
指出能存储为所占位数不大于32bit的数据类型:
bool,byte,char,int,short,float,refrence

####  refrence:可直接找到对应对象所在索引以及对象所属数据类型信息。

#### 64位的long/double存入两个slot空间

**局部变量表占用栈内存，变量越多。如果进行递归调用，每次方法调用会占用更多栈空间，栈空间相同情况下，递归次数会更少**

#### slot复用

当字节码程序计数器值超过变量作用域时，变量对应Slot会交与其它变量使用

**只要被局部变量表直接或间接引用对象都不会被回收**


### 操作数栈:
字节码通过操作数栈进行参数传递，以及作为计算过程中变量存储空间.与字节码指令序列匹配、

两个栈帧往往会进行优化处理，进行重叠。做到共用数据，避免额外参数复制传递

### 栈帧信息

#### 动态链接:

Class文件常量池包含大量符号引用，时指向所属方法的，方法调用是用指令以符号引用做参数进行调用的。
非虚方法(static,final,super，private)在类加载时或第一次使用转化为直接引用，称为静态解析。
虚方法（如接口，或者动态调用，需要在每次运行时判断所属方法）会在运行时转为直接引用，被称为动态链接。

#### 方法返回地址:

存放调用该方法的寄存器值，即调用该方法下一指令地址的


#### 解析调用：非虚方法的调用（编译时可以确定下来的。运行期不可变的方法）

#### 分派调用：

静态分派：发生于编译期间，典型应用为方法重载。虚拟机重载时，是根据变量静态类型选择方法调用的。

动态分派: 发生于运行时，应用为方法重写.


##### 虚拟机方法调用字节码指令:

invokestatic/special/virturl/interface/dynamic



## 堆:

线程共享内存，唯一目的为用于存放对象实例以及数组。

为垃圾收集器的主要区域

新生代：Eden\\Surivivor\\Old
老年代:
元空间:本地内存

新生代在每次GC时都会年龄+1,默认值为15时，则晋升为老年代.阈值为:XX:MaxTenuringThreshold

“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。




著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：https://javaguide.cn/java/jvm/memory-area.html


# 垃圾回收

收集器都采用分代垃圾收集算法





所听说到的优化方法:

虚方法表:存放各方法实际入口地址。
栈顶缓存：栈顶元素存放于CPU寄存器，减少对内存读写次数.
JIT编译器发展以及逃逸分析


## 了解JVM的几个用处

1. 有助于排查线上问题，有足够的基本认知。内存泄露，堆栈溢出之内的。
2. 影响代码编写风格，比如栈