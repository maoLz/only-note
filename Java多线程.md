
### volatile 
volatile 保证了变量的可见性和有序性

**可见性**:
	在多核cpu中，多线程访问同一变量时。将值读入cpu缓存后，只对自己缓存中数据做读写,可能导致结果与预期结果不一致。
	volatile可以使变量的修改立刻通知其他线程所在cpu使缓存失效.
**有序性**:
	通过插入内存屏障，禁止在前后的指令执行重排序优化

### CAS

乐观锁机制(无锁机制)，比较并交换操作,具有原子性
避免了锁机制的开销和线程阻塞
常与自旋绑定，循环直到CAS成功

*缺点*:当线程数过多，导致大量线程不停空转自旋
### synchronized

#### 锁升级

无锁->偏向锁->轻量锁-> 重量锁

#### 偏向锁
同一线程对同一对象重复加锁(重入锁)，发现MarkWord头线程id为自己的，则不再进行CAS加锁解锁.仅有另一个线程进行竞争锁时，通过CAS获取锁，如果获取失败，膨胀为轻量锁。

避免反复获取释放锁，浪费资源

#### 轻量锁:

多线程竞争锁时，竞争锁线程通过CAS自旋竞争锁，如果竞争失败，说明其他线程也在争抢资源。自旋一定次数后则膨胀为重量锁

通过CAS，避免线程的阻塞。减少重量锁的使用，

*自旋多少次升级为重量级锁*

Java6之前：默认10次或者cpu核数的一半
Java6之后：根据同一个线程上次自旋的时间决定

### 重量锁：
加入monitorenter指令，具有计数器功能。保证了synchronized的可重入性
同一线程获取，计数器+1。否则会则阻塞枷锁线程
在阻塞加锁线程，会进行自旋状态空跑取锁。
所以如果锁释放时，阻塞状态无法立刻唤醒进行锁竞争。此时有新线程进行自旋获取则成功获取锁。所以是不公平锁。
### 自旋锁

线程空转去获取锁，以避免线程被阻塞，导致系统在用户态和内核态进行切换，影响性能。但如果自旋时间超出临界值，仍然会被虚拟机扔进阻塞状态。临界值往往取决上一次自旋时间。

	「用户态和内核态切换的开销大」，但是它的开销大在那里呢？(线程切换、阻塞会导致用户态、线程态切换)
	保留用户态现场（上下文、寄存器、用户栈等）
	复制用户态参数，用户栈切到内核栈，进入内核态  
	额外的检查（因为内核代码对用户不信任）  
	执行内核态代码  
	复制内核态代码执行结果，回到用户态
	恢复用户态现场（上下文、寄存器、用户栈等）
### 互斥锁
与自旋锁区分。获取不到锁，直接进入阻塞状态。


### 可重入锁

又称**递归锁**，重入性是*指线程在获取倒锁后可以再次获取该锁而不被阻塞*
*关注*：**线程再次取锁**，**锁的最终释放**
#### 公平锁
锁的获取顺序，严格按照请求的**绝对时间顺序**

#### 非公平锁
非公平锁只要CAS设置同步状态成功，则表示当前线程获取了锁，线程获取锁的顺序和调用lock的顺序无关